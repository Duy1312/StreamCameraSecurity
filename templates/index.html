<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>H·ªá th·ªëng Camera An ninh</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='fonts/roboto.css') }}"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>
  </head>
  <body>
    <header>
      <div class="header-content">
        <h1>H·ªá th·ªëng Camera An ninh</h1>
        <div class="header-actions">
          <span id="active-camera-count">0/20 Camera ƒëang ho·∫°t ƒë·ªông</span>
          <button
            id="refresh-cameras"
            style="margin-left: 10px"
            class="secondary"
          >
            L√†m m·ªõi
          </button>
          <button
            id="stop-all-cameras"
            style="margin-left: 10px"
            class="danger"
          >
            D·ª´ng t·∫•t c·∫£
          </button>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="dashboard">
        <div class="sidebar">
          <div class="tabs">
            <div class="tab-item active" data-tab="cameras">
              Danh s√°ch Camera
            </div>
            <div class="tab-item" data-tab="detection">Ph√°t hi·ªán khu√¥n m·∫∑t</div>
            <div class="tab-item" data-tab="manage">Qu·∫£n l√Ω Camera</div>
            <div class="tab-item" data-tab="realcam">üì∑ Test Camera Th·∫≠t</div>
          </div>

          <div class="tab-content active" id="cameras-tab">
            <div class="form-group">
              <input
                type="text"
                id="camera-search"
                placeholder="T√¨m ki·∫øm camera..."
              />
            </div>
            <div class="camera-list" id="camera-list">
              <!-- Camera list will be populated here -->
            </div>
          </div>

          <div class="tab-content" id="detection-tab">
            <h3>L√™n l·ªãch ph√°t hi·ªán khu√¥n m·∫∑t</h3>

            <!-- Mode selection -->
            <div class="form-group">
              <label>Ch·∫ø ƒë·ªô ph√°t hi·ªán</label>
              <div class="detection-modes">
                <label class="mode-option">
                  <input
                    type="radio"
                    name="detection-mode"
                    value="manual"
                    checked
                  />
                  <span>Th·ªß c√¥ng - Ch·ªçn camera c·ª• th·ªÉ</span>
                </label>
                <label class="mode-option">
                  <input type="radio" name="detection-mode" value="auto" />
                  <span>T·ª± ƒë·ªông - Check 20 camera/60p ƒë·∫øn h·∫øt 400 camera</span>
                </label>
              </div>
            </div>

            <!-- Manual mode -->
            <div id="manual-detection" class="detection-section">
              <div class="manual-info">
                <h4>Ch·∫ø ƒë·ªô th·ªß c√¥ng</h4>
                <p>
                  S·ª≠ d·ª•ng c√°c camera ƒëang ƒë∆∞·ª£c stream ƒë·ªÉ ph√°t hi·ªán khu√¥n m·∫∑t.
                </p>
                <div class="active-cameras-info">
                  <span
                    >Camera ƒëang stream:
                    <strong id="manual-camera-count">0 camera</strong></span
                  >
                  <div id="manual-camera-list" class="active-camera-names">
                    <!-- Active camera names will be shown here -->
                  </div>
                </div>
              </div>
              <div class="form-group">
                <label for="detection-duration">Th·ªùi gian (ph√∫t)</label>
                <input
                  type="number"
                  id="detection-duration"
                  value="60"
                  min="1"
                  max="120"
                />
              </div>
              <button id="schedule-detection-btn">B·∫Øt ƒë·∫ßu ph√°t hi·ªán</button>
            </div>

            <!-- Auto mode -->
            <div
              id="auto-detection"
              class="detection-section"
              style="display: none"
            >
              <div class="auto-schedule-info">
                <h4>Ch·∫ø ƒë·ªô t·ª± ƒë·ªông</h4>
                <p>
                  H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông check 20 camera m·ªói chu k·ª≥ cho ƒë·∫øn khi
                  check h·∫øt 400 camera.
                </p>
                <p>
                  <strong>L∆∞u √Ω:</strong> Th·ªùi gian chu k·ª≥ s·∫Ω √°p d·ª•ng cho c·∫£
                  ph√°t hi·ªán v√† ngh·ªâ gi·ªØa c√°c chu k·ª≥.
                </p>
                <div class="progress-info">
                  <div class="progress-stats">
                    <span
                      >Ti·∫øn tr√¨nh:
                      <strong id="auto-progress">0/400 camera</strong></span
                    >
                    <span
                      >Chu k·ª≥ hi·ªán t·∫°i:
                      <strong id="current-cycle">0/20</strong></span
                    >
                  </div>
                  <div class="progress-bar">
                    <div
                      class="progress-fill"
                      id="progress-fill"
                      style="width: 0%"
                    ></div>
                  </div>
                </div>
              </div>
              <div class="form-group">
                <label for="auto-interval">Th·ªùi gian m·ªói chu k·ª≥ (ph√∫t)</label>
                <input
                  type="number"
                  id="auto-interval"
                  value="60"
                  min="30"
                  max="180"
                />
                <small class="help-text"
                  >Th·ªùi gian ph√°t hi·ªán cho m·ªói nh√≥m 20 camera</small
                >
              </div>
              <button id="start-auto-detection-btn">
                B·∫Øt ƒë·∫ßu ph√°t hi·ªán t·ª± ƒë·ªông
              </button>
              <button
                id="stop-auto-detection-btn"
                class="danger"
                style="display: none"
              >
                D·ª´ng ph√°t hi·ªán t·ª± ƒë·ªông
              </button>
            </div>

            <div
              class="active-detection"
              style="margin-top: 20px; display: none"
            >
              <h4>ƒêang ph√°t hi·ªán khu√¥n m·∫∑t</h4>
              <p id="detection-status"></p>
              <div class="detection-progress" id="detection-progress">
                <div class="time-remaining">
                  <span
                    >Th·ªùi gian c√≤n l·∫°i:
                    <strong id="time-remaining">--:--</strong></span
                  >
                </div>
              </div>
              <button id="stop-detection-btn" class="danger">
                D·ª´ng ph√°t hi·ªán
              </button>
            </div>
          </div>

          <div class="tab-content" id="manage-tab">
            <h3>Qu·∫£n l√Ω Camera</h3>

            <!-- Form th√™m/s·ª≠a camera -->
            <div class="camera-form" id="camera-form">
              <h4 id="form-title">Th√™m Camera M·ªõi</h4>
              <div class="form-group">
                <label for="camera-name">T√™n Camera</label>
                <input
                  type="text"
                  id="camera-name"
                  placeholder="VD: Camera C·ªïng Ch√≠nh"
                  required
                />
              </div>
              <div class="form-group">
                <label for="camera-ip">ƒê·ªãa ch·ªâ IP</label>
                <input
                  type="text"
                  id="camera-ip"
                  placeholder="VD: 192.168.1.100"
                  required
                />
              </div>
              <div class="form-group">
                <label for="camera-location">V·ªã tr√≠</label>
                <input
                  type="text"
                  id="camera-location"
                  placeholder="VD: Khu v·ª±c A, Ph√≤ng 101"
                  required
                />
              </div>
              <div class="form-group">
                <label for="camera-status">Tr·∫°ng th√°i</label>
                <select id="camera-status">
                  <option value="offline">Offline</option>
                  <option value="online">Online</option>
                </select>
              </div>
              <div class="form-actions">
                <button type="button" id="save-camera-btn">L∆∞u Camera</button>
                <button
                  type="button"
                  id="cancel-edit-btn"
                  class="secondary"
                  style="display: none"
                >
                  H·ªßy
                </button>
              </div>
            </div>

            <!-- Danh s√°ch camera ƒë·ªÉ qu·∫£n l√Ω -->
            <div class="camera-management">
              <h4>Danh s√°ch Camera (Qu·∫£n l√Ω)</h4>
              <div class="management-list" id="management-list">
                <!-- Camera management items will be populated here -->
              </div>
            </div>
          </div>

          <div class="tab-content" id="realcam-tab">
            <h3>üì∑ Test Camera Th·∫≠t</h3>
            <div class="real-camera-section">
              <div class="camera-info-box">
                <h4>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:</h4>
                <ul>
                  <li>üé• Nh·∫•n "B·∫≠t Camera" ƒë·ªÉ m·ªü webcam laptop</li>
                  <li>üë§ Nh·∫•n "Test Ph√°t hi·ªán" ƒë·ªÉ scan khu√¥n m·∫∑t</li>
                  <li>üì∏ ·∫¢nh c√≥ khu√¥n m·∫∑t s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông</li>
                  <li>üìä K·∫øt qu·∫£ hi·ªÉn th·ªã trong tab "K·∫øt qu·∫£ ph√°t hi·ªán"</li>
                </ul>
                <div class="browser-support">
                  <p>
                    <strong>üåê Tr√¨nh duy·ªát h·ªó tr·ª£:</strong> Chrome 53+, Firefox
                    36+, Safari 11+, Edge 12+
                  </p>
                  <button
                    id="check-browser-btn"
                    class="camera-btn secondary"
                    style="font-size: 0.8rem; padding: 5px 10px"
                  >
                    ‚úÖ Ki·ªÉm tra tr√¨nh duy·ªát
                  </button>
                </div>
              </div>

              <div class="camera-controls">
                <button id="start-camera-btn" class="camera-btn">
                  üé• B·∫≠t Camera
                </button>
                <button
                  id="stop-camera-btn"
                  class="camera-btn secondary"
                  style="display: none"
                >
                  üõë T·∫Øt Camera
                </button>
                <button
                  id="test-real-detection-btn"
                  class="camera-btn test-detection"
                  disabled
                >
                  üîç Test Ph√°t hi·ªán
                </button>
                <button
                  id="auto-detect-btn"
                  class="camera-btn"
                  disabled
                  style="display: none"
                >
                  ü§ñ T·ª± ƒë·ªông ph√°t hi·ªán
                </button>
              </div>

              <div class="video-container">
                <video
                  id="webcam-video"
                  autoplay
                  muted
                  style="display: none"
                ></video>
                <canvas id="webcam-canvas" style="display: none"></canvas>
                <div id="camera-placeholder" class="camera-placeholder">
                  <div class="placeholder-content">
                    <span class="camera-icon">üì∑</span>
                    <p>Nh·∫•n "B·∫≠t Camera" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                  </div>
                </div>
              </div>

              <div
                class="detection-stats"
                id="detection-stats"
                style="display: none"
              >
                <div class="stat-item">
                  <span class="stat-label">Tests ƒë√£ ch·∫°y:</span>
                  <span class="stat-value" id="tests-count">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Khu√¥n m·∫∑t ph√°t hi·ªán:</span>
                  <span class="stat-value" id="faces-count">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">T·ª∑ l·ªá th√†nh c√¥ng:</span>
                  <span class="stat-value" id="success-rate">0%</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="main-content">
          <div class="tabs">
            <div class="tab-item active" data-tab="stream">Lu·ªìng camera</div>
            <div class="tab-item" data-tab="detections">K·∫øt qu·∫£ ph√°t hi·ªán</div>
          </div>

          <div class="tab-content active" id="stream-tab">
            <div class="alert alert-info" id="stream-alert">
              Ch·ªçn camera t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ b·∫Øt ƒë·∫ßu stream. T·ªëi ƒëa 20
              camera c√≥ th·ªÉ ƒë∆∞·ª£c stream c√πng l√∫c.
            </div>
            <div class="camera-grid" id="camera-grid">
              <!-- Camera streams will be displayed here -->
            </div>
          </div>

          <div class="tab-content" id="detections-tab">
            <div class="alert alert-info" id="detection-alert">
              K·∫øt qu·∫£ ph√°t hi·ªán khu√¥n m·∫∑t s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.
            </div>
            <div class="detection-results" id="detection-results">
              <!-- Detection results will be displayed here -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // K·∫øt n·ªëi Socket.IO
      const socket = io();

      // C√°c bi·∫øn to√†n c·ª•c
      let cameras = {};
      let activeStreams = new Set();
      let detectionResults = [];

      // Camera Management Variables
      let currentEditingCamera = null;

      // Detection Variables
      let selectedCamerasForDetection = new Set();
      let autoDetectionInterval = null;
      let autoDetectionProgress = 0;
      let currentDetectionTimer = null;
      let countdownInterval = null; // Add this to track countdown timer

      // Real Camera Variables
      let webcamStream = null;
      let realCameraStats = {
        testsRun: 0,
        facesDetected: 0,
        successRate: 0,
      };

      // Polyfill for older browsers
      function initializeWebRTC() {
        // Older browser compatibility
        navigator.getUserMedia =
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia ||
          navigator.msGetUserMedia;

        // Modern API fallback
        if (!navigator.mediaDevices && navigator.getUserMedia) {
          navigator.mediaDevices = {
            getUserMedia: function (constraints) {
              return new Promise(function (resolve, reject) {
                navigator.getUserMedia(constraints, resolve, reject);
              });
            },
          };
        }
      }

      // DOM Elements
      const cameraList = document.getElementById("camera-list");
      const cameraGrid = document.getElementById("camera-grid");
      const detectionResults_el = document.getElementById("detection-results");
      const activeCountEl = document.getElementById("active-camera-count");
      const cameraSearch = document.getElementById("camera-search");
      const detectionCamerasSelect =
        document.getElementById("detection-cameras");
      const detectionDuration = document.getElementById("detection-duration");
      const scheduleDetectionBtn = document.getElementById(
        "schedule-detection-btn"
      );
      const stopDetectionBtn = document.getElementById("stop-detection-btn");
      const detectionStatus = document.getElementById("detection-status");
      const activeDetection = document.querySelector(".active-detection");

      // New Detection DOM Elements
      const cameraCheckboxList = document.getElementById(
        "camera-checkbox-list"
      );
      const selectedCountEl = document.getElementById("selected-count");
      const selectAllBtn = document.getElementById("select-all-cameras");
      const clearSelectionBtn = document.getElementById("clear-selection");
      const manualDetectionSection =
        document.getElementById("manual-detection");
      const autoDetectionSection = document.getElementById("auto-detection");
      const startAutoDetectionBtn = document.getElementById(
        "start-auto-detection-btn"
      );
      const stopAutoDetectionBtn = document.getElementById(
        "stop-auto-detection-btn"
      );
      const autoProgressEl = document.getElementById("auto-progress");
      const currentCycleEl = document.getElementById("current-cycle");
      const progressFillEl = document.getElementById("progress-fill");
      const timeRemainingEl = document.getElementById("time-remaining");
      const manualCameraCountEl = document.getElementById(
        "manual-camera-count"
      );
      const manualCameraListEl = document.getElementById("manual-camera-list");

      // DOM Elements for camera management
      const cameraForm = document.getElementById("camera-form");
      const formTitle = document.getElementById("form-title");
      const cameraNameInput = document.getElementById("camera-name");
      const cameraIpInput = document.getElementById("camera-ip");
      const cameraLocationInput = document.getElementById("camera-location");
      const cameraStatusSelect = document.getElementById("camera-status");
      const saveCameraBtn = document.getElementById("save-camera-btn");
      const cancelEditBtn = document.getElementById("cancel-edit-btn");
      const managementList = document.getElementById("management-list");

      // Real Camera DOM Elements
      const startCameraBtn = document.getElementById("start-camera-btn");
      const stopCameraBtn = document.getElementById("stop-camera-btn");
      const testRealDetectionBtn = document.getElementById(
        "test-real-detection-btn"
      );
      const webcamVideo = document.getElementById("webcam-video");
      const webcamCanvas = document.getElementById("webcam-canvas");
      const cameraPlaceholder = document.getElementById("camera-placeholder");
      const detectionStats = document.getElementById("detection-stats");
      const testsCountEl = document.getElementById("tests-count");
      const facesCountEl = document.getElementById("faces-count");
      const successRateEl = document.getElementById("success-rate");

      // Tab navigation
      document.querySelectorAll(".tab-item").forEach((tab) => {
        tab.addEventListener("click", () => {
          const tabName = tab.getAttribute("data-tab");
          const tabContainer = tab.closest(".sidebar, .main-content");

          console.log(
            "Tab clicked:",
            tabName,
            "in container:",
            tabContainer.className
          );

          // Activate tab ch·ªâ trong container hi·ªán t·∫°i
          tabContainer
            .querySelectorAll(".tab-item")
            .forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");

          // Show tab content ch·ªâ trong container hi·ªán t·∫°i
          tabContainer
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.remove("active"));
          const targetTab = tabContainer.querySelector(`#${tabName}-tab`);
          console.log("Target tab element:", targetTab);
          if (targetTab) {
            targetTab.classList.add("active");
          }
        });
      });

      // Fetch cameras
      async function fetchCameras() {
        try {
          const response = await fetch("/api/cameras");
          cameras = await response.json();
          renderCameraList();
          populateDetectionCameras();
          renderManagementList();
          return true;
        } catch (error) {
          console.error("Error fetching cameras:", error);
          return false;
        }
      }

      // Fetch active streams
      async function fetchActiveStreams() {
        try {
          const response = await fetch("/api/active-streams");
          const streams = await response.json();

          // Load from localStorage first
          const savedStreams = localStorage.getItem("activeStreams");
          if (savedStreams) {
            activeStreams = new Set(JSON.parse(savedStreams));
          }

          // Merge with server data
          streams.forEach((streamId) => activeStreams.add(streamId));

          // If we have saved streams but server doesn't, sync with server
          if (savedStreams && streams.length === 0) {
            activeStreams.forEach(async (cameraId) => {
              await fetch("/api/start-stream", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ camera_id: cameraId }),
              });
            });
          }

          // Save current state
          saveActiveStreams();

          updateActiveCount();
          renderCameraGrid();
          renderCameraList(); // Re-render ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i active
        } catch (error) {
          console.error("Error fetching active streams:", error);
        }
      }

      // Save active streams to localStorage
      function saveActiveStreams() {
        localStorage.setItem(
          "activeStreams",
          JSON.stringify([...activeStreams])
        );
      }

      // Fetch detection results
      async function fetchDetectionResults() {
        try {
          console.log("Fetching detection results...");
          const response = await fetch("/api/detection-results");
          const data = await response.json();
          console.log("Detection results received:", data);

          detectionResults = data;
          renderDetectionResults();
          console.log("Detection results rendered");
        } catch (error) {
          console.error("Error fetching detection results:", error);
        }
      }

      // Render camera list
      function renderCameraList() {
        cameraList.innerHTML = "";

        const searchTerm = cameraSearch.value.toLowerCase();

        Object.values(cameras)
          .filter((camera) => {
            return (
              camera.name.toLowerCase().includes(searchTerm) ||
              camera.location.toLowerCase().includes(searchTerm) ||
              camera.ip.toLowerCase().includes(searchTerm)
            );
          })
          .forEach((camera) => {
            const isActive = activeStreams.has(camera.id);

            const cameraItem = document.createElement("div");
            cameraItem.className = `camera-item ${isActive ? "active" : ""}`;
            cameraItem.dataset.id = camera.id;

            cameraItem.innerHTML = `
                        <div>
                            <span class="camera-status ${
                              camera.status === "online"
                                ? "status-online"
                                : "status-offline"
                            }"></span>
                            ${camera.name}
                        </div>
                        <div class="camera-item-location">${
                          camera.location
                        }</div>
                    `;

            cameraItem.addEventListener("click", () =>
              addCameraToStream(camera.id)
            );

            cameraList.appendChild(cameraItem);
          });
      }

      // Populate detection cameras select
      function populateDetectionCameras() {
        // This function is no longer needed for the new UI
        // Manual mode uses activeStreams, auto mode doesn't need selection
      }

      // Update selected camera count
      function updateSelectedCount() {
        selectedCountEl.textContent = `${selectedCamerasForDetection.size}/20 camera ƒë∆∞·ª£c ch·ªçn`;
      }

      // Detection mode handling
      function handleDetectionModeChange() {
        const selectedMode = document.querySelector(
          'input[name="detection-mode"]:checked'
        ).value;

        if (selectedMode === "manual") {
          manualDetectionSection.style.display = "block";
          autoDetectionSection.style.display = "none";

          // Enable camera selection in sidebar
          cameraList.classList.remove("disabled");

          // Update manual mode info
          updateManualModeInfo();
        } else {
          manualDetectionSection.style.display = "none";
          autoDetectionSection.style.display = "block";

          // Disable camera selection in sidebar to prevent exceeding 20 cameras
          cameraList.classList.add("disabled");

          updateAutoProgress();
        }
      }

      // Update manual mode camera info
      function updateManualModeInfo() {
        const activeCameraCount = activeStreams.size;
        manualCameraCountEl.textContent = `${activeCameraCount} camera`;

        // Clear and populate active camera list
        manualCameraListEl.innerHTML = "";

        if (activeCameraCount === 0) {
          manualCameraListEl.innerHTML =
            '<div style="color: #666; font-style: italic;">Ch∆∞a c√≥ camera n√†o ƒë∆∞·ª£c ch·ªçn. H√£y ch·ªçn camera t·ª´ danh s√°ch b√™n tr√°i.</div>';
        } else {
          [...activeStreams].forEach((cameraId) => {
            const camera = cameras[cameraId];
            if (camera) {
              const cameraItem = document.createElement("div");
              cameraItem.className = "camera-name-item";
              cameraItem.innerHTML = `
                <span class="camera-status ${
                  camera.status === "online"
                    ? "status-online"
                    : "status-offline"
                }"></span>
                ${camera.name} (${camera.location})
              `;
              manualCameraListEl.appendChild(cameraItem);
            }
          });
        }
      }

      // Select all cameras
      function selectAllCameras() {
        selectedCamerasForDetection.clear();
        const checkboxes = cameraCheckboxList.querySelectorAll(
          'input[type="checkbox"]'
        );
        let count = 0;

        checkboxes.forEach((checkbox) => {
          if (count < 20) {
            checkbox.checked = true;
            selectedCamerasForDetection.add(checkbox.value);
            checkbox.closest(".camera-checkbox-item").classList.add("selected");
            count++;
          }
        });

        updateSelectedCount();
      }

      // Clear selection
      function clearSelection() {
        selectedCamerasForDetection.clear();
        const checkboxes = cameraCheckboxList.querySelectorAll(
          'input[type="checkbox"]'
        );

        checkboxes.forEach((checkbox) => {
          checkbox.checked = false;
          checkbox
            .closest(".camera-checkbox-item")
            .classList.remove("selected");
        });

        updateSelectedCount();
      }

      // Update auto detection progress
      function updateAutoProgress() {
        autoProgressEl.textContent = `${autoDetectionProgress}/400 camera`;
        const progressPercent = (autoDetectionProgress / 400) * 100;
        progressFillEl.style.width = `${progressPercent}%`;
      }

      // Start auto detection
      async function startAutoDetection() {
        const interval = parseInt(
          document.getElementById("auto-interval").value
        );

        if (isNaN(interval) || interval < 30 || interval > 180) {
          showToast("Kho·∫£ng th·ªùi gian ph·∫£i t·ª´ 30 ƒë·∫øn 180 ph√∫t", "warning");
          return;
        }

        // Reset progress if starting fresh
        if (autoDetectionProgress >= 400) {
          autoDetectionProgress = 0;
          updateAutoProgress();
        }

        // Clear manual camera selections when starting auto detection
        const previousStreams = [...activeStreams];
        for (const cameraId of previousStreams) {
          await fetch("/api/stop-stream", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ camera_id: cameraId }),
          });
        }
        activeStreams.clear();
        saveActiveStreams();
        renderCameraGrid();
        updateActiveCount();

        startAutoDetectionBtn.style.display = "none";
        stopAutoDetectionBtn.style.display = "inline-block";

        showToast(
          "ƒê√£ b·∫Øt ƒë·∫ßu ph√°t hi·ªán t·ª± ƒë·ªông! Camera manual ƒë√£ ƒë∆∞·ª£c b·ªè ch·ªçn.",
          "success"
        );

        // Start the auto detection cycle
        await runAutoDetectionCycle(interval);
      }

      // Stop auto detection
      function stopAutoDetection() {
        if (autoDetectionInterval) {
          clearInterval(autoDetectionInterval);
          autoDetectionInterval = null;
        }

        if (currentDetectionTimer) {
          clearTimeout(currentDetectionTimer);
          currentDetectionTimer = null;
        }

        // Clear countdown timer
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }

        // Clear current auto detection cameras from streams
        activeStreams.clear();
        saveActiveStreams();
        renderCameraGrid();
        updateActiveCount();

        startAutoDetectionBtn.style.display = "inline-block";
        stopAutoDetectionBtn.style.display = "none";

        activeDetection.style.display = "none";

        // Reset time display
        timeRemainingEl.textContent = "--:--";

        showToast("ƒê√£ d·ª´ng ph√°t hi·ªán t·ª± ƒë·ªông", "info");
      }

      // Run auto detection cycle
      async function runAutoDetectionCycle(interval) {
        const cameraIds = Object.keys(cameras);

        const runCycle = async () => {
          if (autoDetectionProgress >= 400) {
            stopAutoDetection();
            showToast("ƒê√£ ho√†n th√†nh ph√°t hi·ªán t·∫•t c·∫£ 400 camera!", "success");
            return;
          }

          // Get next 20 cameras
          const startIndex = autoDetectionProgress;
          const endIndex = Math.min(startIndex + 20, 400);
          const camerasForThisCycle = cameraIds.slice(startIndex, endIndex);

          if (camerasForThisCycle.length === 0) {
            stopAutoDetection();
            return;
          }

          // Clear previous cycle cameras from streams
          const previousStreams = [...activeStreams];
          for (const cameraId of previousStreams) {
            await fetch("/api/stop-stream", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ camera_id: cameraId }),
            });
          }
          activeStreams.clear();

          // Add current cycle cameras to active streams for display
          for (const cameraId of camerasForThisCycle) {
            if (cameras[cameraId]) {
              activeStreams.add(cameraId);
              // Start stream for display
              await fetch("/api/start-stream", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ camera_id: cameraId }),
              });
            }
          }

          // Update UI to show current cycle cameras
          saveActiveStreams();
          renderCameraGrid();
          updateActiveCount();

          // Update current cycle info
          currentCycleEl.textContent = `${camerasForThisCycle.length}/20`;

          // Show active detection
          activeDetection.style.display = "block";
          detectionStatus.textContent = `ƒêang ph√°t hi·ªán khu√¥n m·∫∑t t·ª± ƒë·ªông: Camera ${
            startIndex + 1
          } - ${endIndex} (Chu k·ª≥ ${Math.ceil(
            endIndex / 20
          )}/20) - ${interval} ph√∫t`;

          // Start detection for this cycle
          try {
            const response = await fetch("/api/schedule-detection", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                camera_ids: camerasForThisCycle,
                duration: interval, // Use interval time instead of fixed 60 minutes
              }),
            });

            const result = await response.json();

            if (result.schedule_id) {
              // Start countdown timer with user-selected interval
              startCountdownTimer(interval);

              // Wait for detection to complete
              currentDetectionTimer = setTimeout(() => {
                autoDetectionProgress = endIndex;
                updateAutoProgress();

                showToast(
                  `Ho√†n th√†nh chu k·ª≥ ${Math.ceil(endIndex / 20)}/20`,
                  "success"
                );

                // Schedule next cycle if not at the end
                if (autoDetectionProgress < 400) {
                  showToast(
                    `Ch·ªù ${interval} ph√∫t tr∆∞·ªõc chu k·ª≥ ti·∫øp theo...`,
                    "info"
                  );
                } else {
                  // Clear streams when completely done
                  activeStreams.clear();
                  saveActiveStreams();
                  renderCameraGrid();
                  updateActiveCount();
                  activeDetection.style.display = "none";
                }
              }, interval * 60 * 1000); // Use interval time in milliseconds
            }
          } catch (error) {
            console.error("Error in auto detection cycle:", error);
            showToast("L·ªói trong chu k·ª≥ ph√°t hi·ªán t·ª± ƒë·ªông", "error");
          }
        };

        // Run first cycle immediately
        await runCycle();

        // Set interval for subsequent cycles
        autoDetectionInterval = setInterval(runCycle, interval * 60 * 1000);
      }

      // Start countdown timer
      function startCountdownTimer(minutes) {
        // Clear any existing countdown timer
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }

        let timeLeft = minutes * 60; // Convert to seconds

        const updateTimer = () => {
          const mins = Math.floor(timeLeft / 60);
          const secs = timeLeft % 60;
          timeRemainingEl.textContent = `${mins
            .toString()
            .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;

          if (timeLeft <= 0) {
            timeRemainingEl.textContent = "00:00";
            if (countdownInterval) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
            return;
          }

          timeLeft--;
        };

        // Start the countdown immediately
        updateTimer();

        // Then update every second
        countdownInterval = setInterval(updateTimer, 1000);
      }

      // Toggle camera stream
      async function toggleCameraStream(cameraId) {
        try {
          if (activeStreams.has(cameraId)) {
            // Stop stream
            await fetch("/api/stop-stream", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ camera_id: cameraId }),
            });

            activeStreams.delete(cameraId);
          } else {
            // Check if we're at the limit
            if (activeStreams.size >= 20) {
              showToast(
                "Kh√¥ng th·ªÉ stream qu√° 20 camera c√πng l√∫c. Vui l√≤ng d·ª´ng m·ªôt camera kh√°c tr∆∞·ªõc.",
                "warning"
              );
              return;
            }

            // Start stream
            await fetch("/api/start-stream", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ camera_id: cameraId }),
            });

            activeStreams.add(cameraId);
          }

          // Save to localStorage
          saveActiveStreams();

          renderCameraList();
          renderCameraGrid();
          updateActiveCount();
        } catch (error) {
          console.error("Error toggling camera stream:", error);
        }
      }

      // Render camera grid
      function renderCameraGrid() {
        console.log("Rendering camera grid, active streams:", [
          ...activeStreams,
        ]);
        cameraGrid.innerHTML = "";

        if (activeStreams.size === 0) {
          document.getElementById("stream-alert").style.display = "block";
          updateManualModeInfo(); // Update manual mode info when no cameras
          return;
        }

        document.getElementById("stream-alert").style.display = "none";

        // Check if we're in auto detection mode
        const selectedMode = document.querySelector(
          'input[name="detection-mode"]:checked'
        )?.value;
        const isAutoMode = selectedMode === "auto";

        [...activeStreams].forEach((cameraId) => {
          const camera = cameras[cameraId];
          if (!camera) {
            console.warn("Camera not found:", cameraId);
            return;
          }

          const cameraCard = document.createElement("div");
          cameraCard.className = `camera-card ${
            isAutoMode ? "auto-detection" : ""
          }`;

          cameraCard.innerHTML = `
            <div class="camera-feed">
              <img src="/static/images/camera-placeholder.svg" alt="${
                camera.name
              }" id="feed-${camera.id}">
              ${isAutoMode ? '<div class="auto-badge">ü§ñ T·ª± ƒë·ªông</div>' : ""}
            </div>
            <div class="camera-info">
              <h3>${camera.name}</h3>
              <div class="camera-details">IP: ${camera.ip}</div>
              <div class="camera-details">V·ªã tr√≠: ${camera.location}</div>
              <div class="camera-actions">
                <button class="secondary" onclick="event.stopPropagation(); toggleFullscreen('${
                  camera.id
                }')">Ph√≥ng to</button>
                <button class="test-detection" onclick="event.stopPropagation(); testFaceDetection('${
                  camera.id
                }')">üß™ Test</button>
                ${
                  !isAutoMode
                    ? `<button class="danger" onclick="event.stopPropagation(); removeCameraFromStream('${camera.id}')">D·ª´ng</button>`
                    : '<span class="auto-mode-note">Ch·∫ø ƒë·ªô t·ª± ƒë·ªông</span>'
                }
              </div>
            </div>
          `;

          cameraGrid.appendChild(cameraCard);

          // Trong th·ª±c t·∫ø, b·∫°n s·∫Ω k·∫øt n·ªëi v·ªõi stream th·ª±c t·ª´ camera
          // ƒê√¢y l√† m√¥ ph·ªèng b·∫±ng c√°ch c·∫≠p nh·∫≠t ·∫£nh m·ªói 1 gi√¢y
          simulateCameraFeed(camera.id);
        });

        // Update manual mode info when camera grid changes
        updateManualModeInfo();
      }

      // Render detection results
      function renderDetectionResults() {
        console.log(
          "Rendering detection results. Count:",
          detectionResults.length
        );
        detectionResults_el.innerHTML = "";

        if (detectionResults.length === 0) {
          console.log("No detection results to display");
          document.getElementById("detection-alert").style.display = "block";
          return;
        }

        console.log("Hiding detection alert, showing results");
        document.getElementById("detection-alert").style.display = "none";

        // S·∫Øp x·∫øp theo th·ªùi gian m·ªõi nh·∫•t
        detectionResults.sort((a, b) => b.timestamp - a.timestamp);

        detectionResults.forEach((result, index) => {
          console.log(`Rendering detection ${index}:`, result);
          const camera = cameras[result.camera_id] ||
            result.camera_info || {
              name: "Camera Laptop",
              location: "Webcam",
              ip: "localhost",
              id: result.camera_id,
            };

          if (!camera) {
            console.warn("Camera not found for result:", result.camera_id);
            return;
          }

          // Handle timestamp - could be string or number
          let timestamp = result.timestamp;
          if (typeof timestamp === "string") {
            timestamp = parseInt(timestamp);
          }

          const date = new Date(timestamp * 1000);
          const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;

          const isTestMode = result.test_mode ? true : false;
          const isRealCamera = result.real_camera ? true : false;

          const detectionItem = document.createElement("div");
          detectionItem.className = `detection-item ${
            isTestMode ? "test-detection-item" : ""
          } ${isRealCamera ? "real-camera-item" : ""}`;

          detectionItem.innerHTML = `
            <img src="${
              result.image_path
            }" class="detection-thumbnail" alt="Detection result">
            <div class="detection-info">
              <h4>${camera.name} ${isTestMode ? "üß™ (TEST)" : ""} ${
            isRealCamera ? "üì∑ (REAL)" : ""
          }</h4>
              <p>V·ªã tr√≠: ${camera.location}</p>
              <p>Th·ªùi gian: ${formattedDate}</p>
              <p>IP: ${camera.ip}</p>
              ${isTestMode ? '<p class="test-badge">Ch·∫ø ƒë·ªô test</p>' : ""}
              ${
                isRealCamera
                  ? `<p class="real-badge">Camera th·∫≠t - ${
                      result.faces_detected || 1
                    } khu√¥n m·∫∑t</p>`
                  : ""
              }
            </div>
          `;

          detectionResults_el.appendChild(detectionItem);
        });

        console.log("Detection results rendering completed");
      }

      // Update active camera count
      function updateActiveCount() {
        activeCountEl.textContent = `${activeStreams.size}/20 Camera ƒëang ho·∫°t ƒë·ªông`;
      }

      // Simulate camera feed
      function simulateCameraFeed(cameraId) {
        const feedEl = document.getElementById(`feed-${cameraId}`);
        if (!feedEl) return;

        // M√¥ ph·ªèng c·∫≠p nh·∫≠t ·∫£nh t·ª´ camera
        // Trong th·ª±c t·∫ø, b·∫°n s·∫Ω k·∫øt n·ªëi v·ªõi stream th·ª±c t·ª´ camera
        let counter = 0;
        const interval = setInterval(() => {
          // Ki·ªÉm tra xem camera c√≤n trong danh s√°ch active kh√¥ng
          if (!activeStreams.has(cameraId)) {
            clearInterval(interval);
            return;
          }

          // Ki·ªÉm tra xem element c√≤n t·ªìn t·∫°i kh√¥ng
          const el = document.getElementById(`feed-${cameraId}`);
          if (!el) {
            clearInterval(interval);
            return;
          }

          // M√¥ ph·ªèng ·∫£nh thay ƒë·ªïi
          counter++;
          // Trong th·ª±c t·∫ø b·∫°n s·∫Ω l·∫•y frame th·ª±c t·ª´ camera
          // ·ªû ƒë√¢y ch√∫ng ta ch·ªâ thay ƒë·ªïi timestamp ƒë·ªÉ m√¥ ph·ªèng
          el.src = `/static/images/camera-placeholder.svg?t=${Date.now()}`;
        }, 1000);
      }

      // Schedule face detection
      scheduleDetectionBtn.addEventListener("click", async () => {
        const selectedCameras = [...activeStreams]; // Use active streams instead of selectedCamerasForDetection
        const duration = parseInt(detectionDuration.value);

        if (selectedCameras.length === 0) {
          showToast(
            "Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 camera t·ª´ danh s√°ch camera b√™n tr√°i.",
            "warning"
          );
          return;
        }

        if (selectedCameras.length > 20) {
          showToast("Kh√¥ng th·ªÉ ph√°t hi·ªán qu√° 20 camera c√πng l√∫c.", "warning");
          return;
        }

        if (isNaN(duration) || duration < 1 || duration > 120) {
          showToast("Th·ªùi gian ph·∫£i t·ª´ 1 ƒë·∫øn 120 ph√∫t.", "warning");
          return;
        }

        try {
          const response = await fetch("/api/schedule-detection", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              camera_ids: selectedCameras,
              duration: duration,
            }),
          });

          const result = await response.json();

          if (result.schedule_id) {
            // Show active detection UI
            activeDetection.style.display = "block";
            detectionStatus.textContent = `ƒêang ph√°t hi·ªán khu√¥n m·∫∑t tr√™n ${selectedCameras.length} camera trong ${duration} ph√∫t.`;

            // Disable schedule button
            scheduleDetectionBtn.disabled = true;

            // Start countdown timer
            startCountdownTimer(duration);

            showToast(
              `ƒê√£ b·∫Øt ƒë·∫ßu ph√°t hi·ªán khu√¥n m·∫∑t tr√™n ${selectedCameras.length} camera`,
              "success"
            );

            // Set a timer to update UI when detection completes
            setTimeout(() => {
              activeDetection.style.display = "none";
              scheduleDetectionBtn.disabled = false;
              fetchDetectionResults();
              showToast("Ph√°t hi·ªán khu√¥n m·∫∑t ƒë√£ ho√†n th√†nh", "info");
            }, duration * 60 * 1000);
          }
        } catch (error) {
          console.error("Error scheduling detection:", error);
        }
      });

      // Stop detection
      stopDetectionBtn.addEventListener("click", () => {
        // Clear detection timer
        if (currentDetectionTimer) {
          clearTimeout(currentDetectionTimer);
          currentDetectionTimer = null;
        }

        // Clear countdown timer
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }

        // Update UI
        activeDetection.style.display = "none";
        scheduleDetectionBtn.disabled = false;

        // Reset time display
        timeRemainingEl.textContent = "--:--";

        showToast("ƒê√£ d·ª´ng ph√°t hi·ªán khu√¥n m·∫∑t", "info");
      });

      // Toggle fullscreen
      function toggleFullscreen(cameraId) {
        const feedEl = document.getElementById(`feed-${cameraId}`);
        if (!feedEl) return;

        if (!document.fullscreenElement) {
          feedEl.requestFullscreen().catch((err) => {
            console.error(
              `Error attempting to enable fullscreen: ${err.message}`
            );
          });
        } else {
          document.exitFullscreen();
        }
      }

      // Search functionality
      cameraSearch.addEventListener("input", () => {
        renderCameraList();
      });

      // Socket.IO events
      socket.on("connect", () => {
        console.log("Connected to server");
      });

      socket.on("face_detected", (data) => {
        console.log("Face detected:", data);

        // Add to detection results immediately
        detectionResults.unshift(data);
        renderDetectionResults();

        // Show notification
        const camera = cameras[data.camera_id];
        if (camera) {
          const isTestMode = data.test_mode ? " (TEST)" : "";
          const message = `Ph√°t hi·ªán khu√¥n m·∫∑t${isTestMode} tr√™n camera ${camera.name} t·∫°i ${camera.location}`;

          showToast(message, data.test_mode ? "info" : "success");

          // Browser notification
          if (Notification.permission === "granted") {
            new Notification("Ph√°t hi·ªán khu√¥n m·∫∑t" + isTestMode, {
              body: message,
              icon: data.image_path,
            });
          }
        }
      });

      // Toast notification function
      function showToast(message, type = "success") {
        // Remove existing toast
        const existingToast = document.querySelector(".toast");
        if (existingToast) {
          existingToast.remove();
        }

        // Create new toast
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;

        // Add to body
        document.body.appendChild(toast);

        // Show toast
        setTimeout(() => {
          toast.classList.add("show");
        }, 100);

        // Hide and remove toast
        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => {
            toast.remove();
          }, 300);
        }, 3000);
      }

      // Refresh cameras
      async function refreshCameras() {
        const refreshBtn = document.getElementById("refresh-cameras");
        const originalText = refreshBtn.textContent;

        try {
          // Show loading state
          refreshBtn.disabled = true;
          refreshBtn.textContent = "ƒêang t·∫£i...";
          refreshBtn.style.opacity = "0.6";

          // Clear current data
          cameras = {};
          activeStreams.clear();

          // Fetch fresh data
          console.log("Refreshing cameras...");
          await fetchCameras();
          await fetchActiveStreams();
          await fetchDetectionResults();

          // Show success message
          const originalCount = Object.keys(cameras).length;
          showToast(
            `L√†m m·ªõi th√†nh c√¥ng! ƒê√£ t·∫£i ${originalCount} camera.`,
            "success"
          );

          console.log("Refresh completed successfully");
        } catch (error) {
          console.error("Error refreshing cameras:", error);
          showToast("C√≥ l·ªói x·∫£y ra khi l√†m m·ªõi d·ªØ li·ªáu", "error");
        } finally {
          // Restore button state
          refreshBtn.disabled = false;
          refreshBtn.textContent = originalText;
          refreshBtn.style.opacity = "1";
        }
      }

      // Stop all cameras
      async function stopAllCameras() {
        const camerasToStop = [...activeStreams];
        for (const cameraId of camerasToStop) {
          await removeCameraFromStream(cameraId);
        }
      }

      // Initialization
      document.addEventListener("DOMContentLoaded", async () => {
        // Initialize WebRTC polyfill
        initializeWebRTC();

        // Load cameras first
        await fetchCameras();

        // Then load active streams and render
        await fetchActiveStreams();

        // Load detection results
        fetchDetectionResults();

        // Camera management event listeners
        saveCameraBtn.addEventListener("click", saveCamera);
        cancelEditBtn.addEventListener("click", clearForm);

        // Detection mode event listeners
        document
          .querySelectorAll('input[name="detection-mode"]')
          .forEach((radio) => {
            radio.addEventListener("change", handleDetectionModeChange);
          });

        // Auto detection event listeners
        startAutoDetectionBtn.addEventListener("click", startAutoDetection);
        stopAutoDetectionBtn.addEventListener("click", stopAutoDetection);

        // Real Camera event listeners
        startCameraBtn.addEventListener("click", startWebcam);
        stopCameraBtn.addEventListener("click", stopWebcam);
        testRealDetectionBtn.addEventListener("click", testRealFaceDetection);
        document
          .getElementById("check-browser-btn")
          .addEventListener("click", checkBrowserSupport);

        // Initialize detection mode
        handleDetectionModeChange();

        // Refresh cameras button
        document
          .getElementById("refresh-cameras")
          .addEventListener("click", refreshCameras);

        // Stop all cameras button
        document
          .getElementById("stop-all-cameras")
          .addEventListener("click", stopAllCameras);

        // C·∫≠p nh·∫≠t m·ªói 30 gi√¢y
        setInterval(() => {
          fetchDetectionResults();
        }, 30000);

        // Y√™u c·∫ßu quy·ªÅn th√¥ng b√°o
        if (
          Notification.permission !== "granted" &&
          Notification.permission !== "denied"
        ) {
          Notification.requestPermission();
        }
      });

      // Add camera to stream (without removing others)
      async function addCameraToStream(cameraId) {
        try {
          // Check if in auto detection mode and prevent adding cameras
          const selectedMode = document.querySelector(
            'input[name="detection-mode"]:checked'
          )?.value;
          if (selectedMode === "auto") {
            showToast(
              "Kh√¥ng th·ªÉ th√™m camera khi ƒëang ·ªü ch·∫ø ƒë·ªô ph√°t hi·ªán t·ª± ƒë·ªông",
              "warning"
            );
            return;
          }

          // Check if camera is already streaming
          if (activeStreams.has(cameraId)) {
            return; // Already streaming, do nothing
          }

          // Check if we're at the limit
          if (activeStreams.size >= 20) {
            showToast(
              "Kh√¥ng th·ªÉ stream qu√° 20 camera c√πng l√∫c. Vui l√≤ng d·ª´ng m·ªôt camera kh√°c tr∆∞·ªõc.",
              "warning"
            );
            return;
          }

          // Start stream
          await fetch("/api/start-stream", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ camera_id: cameraId }),
          });

          activeStreams.add(cameraId);

          // Save to localStorage
          saveActiveStreams();

          renderCameraList();
          renderCameraGrid();
          updateActiveCount();
        } catch (error) {
          console.error("Error adding camera to stream:", error);
        }
      }

      // Remove camera from stream
      async function removeCameraFromStream(cameraId) {
        try {
          if (!activeStreams.has(cameraId)) {
            return; // Not streaming, do nothing
          }

          // Stop stream
          await fetch("/api/stop-stream", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ camera_id: cameraId }),
          });

          activeStreams.delete(cameraId);

          // Save to localStorage
          saveActiveStreams();

          renderCameraList();
          renderCameraGrid();
          updateActiveCount();
        } catch (error) {
          console.error("Error removing camera from stream:", error);
        }
      }

      // Camera Management Functions
      function renderManagementList() {
        managementList.innerHTML = "";

        Object.values(cameras).forEach((camera) => {
          const managementItem = document.createElement("div");
          managementItem.className = "management-item";

          managementItem.innerHTML = `
            <div class="management-item-info">
              <h5>${camera.name}</h5>
              <p>IP: ${camera.ip} | V·ªã tr√≠: ${camera.location}</p>
              <p>Tr·∫°ng th√°i: <span class="camera-status ${
                camera.status === "online" ? "status-online" : "status-offline"
              }"></span> ${camera.status}</p>
            </div>
            <div class="management-item-actions">
              <button class="btn-edit" onclick="editCamera('${
                camera.id
              }')">S·ª≠a</button>
              <button class="btn-delete" onclick="deleteCamera('${
                camera.id
              }')">X√≥a</button>
            </div>
          `;

          managementList.appendChild(managementItem);
        });
      }

      function clearForm() {
        cameraNameInput.value = "";
        cameraIpInput.value = "";
        cameraLocationInput.value = "";
        cameraStatusSelect.value = "offline";
        currentEditingCamera = null;
        formTitle.textContent = "Th√™m Camera M·ªõi";
        saveCameraBtn.textContent = "L∆∞u Camera";
        cancelEditBtn.style.display = "none";
      }

      async function saveCamera() {
        const name = cameraNameInput.value.trim();
        const ip = cameraIpInput.value.trim();
        const location = cameraLocationInput.value.trim();
        const status = cameraStatusSelect.value;

        if (!name || !ip || !location) {
          showToast("Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin camera", "warning");
          return;
        }

        // Disable save button during request
        saveCameraBtn.disabled = true;
        saveCameraBtn.textContent = currentEditingCamera
          ? "ƒêang c·∫≠p nh·∫≠t..."
          : "ƒêang l∆∞u...";

        try {
          let response;
          if (currentEditingCamera) {
            // Update existing camera
            response = await fetch(`/api/cameras/${currentEditingCamera}`, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ name, ip, location, status }),
            });
          } else {
            // Add new camera
            response = await fetch("/api/cameras", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ name, ip, location, status }),
            });
          }

          const result = await response.json();

          if (result.success) {
            showToast(
              currentEditingCamera
                ? "Camera ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!"
                : "Camera m·ªõi ƒë√£ ƒë∆∞·ª£c th√™m!",
              "success"
            );
            clearForm();
            await fetchCameras();
            renderManagementList();
          } else {
            showToast("L·ªói: " + result.error, "error");
          }
        } catch (error) {
          console.error("Error saving camera:", error);
          showToast("C√≥ l·ªói x·∫£y ra khi l∆∞u camera", "error");
        } finally {
          // Restore save button
          saveCameraBtn.disabled = false;
          saveCameraBtn.textContent = currentEditingCamera
            ? "C·∫≠p nh·∫≠t Camera"
            : "L∆∞u Camera";
        }
      }

      function editCamera(cameraId) {
        const camera = cameras[cameraId];
        if (!camera) return;

        currentEditingCamera = cameraId;
        cameraNameInput.value = camera.name;
        cameraIpInput.value = camera.ip;
        cameraLocationInput.value = camera.location;
        cameraStatusSelect.value = camera.status;

        formTitle.textContent = "S·ª≠a Camera";
        saveCameraBtn.textContent = "C·∫≠p nh·∫≠t Camera";
        cancelEditBtn.style.display = "inline-block";
      }

      async function deleteCamera(cameraId) {
        const camera = cameras[cameraId];
        if (!camera) return;

        if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a camera "${camera.name}"?`)) {
          return;
        }

        try {
          const response = await fetch(`/api/cameras/${cameraId}`, {
            method: "DELETE",
          });

          const result = await response.json();

          if (result.success) {
            showToast("Camera ƒë√£ ƒë∆∞·ª£c x√≥a!", "success");
            await fetchCameras();
            renderManagementList();

            // Remove from active streams if it was streaming
            if (activeStreams.has(cameraId)) {
              activeStreams.delete(cameraId);
              saveActiveStreams();
              renderCameraGrid();
              updateActiveCount();
            }
          } else {
            showToast("L·ªói: " + result.error, "error");
          }
        } catch (error) {
          console.error("Error deleting camera:", error);
          showToast("C√≥ l·ªói x·∫£y ra khi x√≥a camera", "error");
        }
      }

      // Test face detection for a specific camera
      async function testFaceDetection(cameraId) {
        try {
          const camera = cameras[cameraId];
          if (!camera) {
            showToast("Camera kh√¥ng t·ªìn t·∫°i", "error");
            return;
          }

          showToast(
            `ƒêang test ph√°t hi·ªán khu√¥n m·∫∑t cho ${camera.name}...`,
            "info"
          );

          const response = await fetch("/api/test-face-detection", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ camera_id: cameraId }),
          });

          const result = await response.json();

          if (result.success) {
            showToast(
              `‚úÖ Test th√†nh c√¥ng! ƒê√£ ph√°t hi·ªán khu√¥n m·∫∑t tr√™n ${camera.name}`,
              "success"
            );

            // Automatically switch to detection results tab
            const detectionsTab = document.querySelector(
              '.main-content .tab-item[data-tab="detections"]'
            );
            if (detectionsTab) {
              detectionsTab.click();
            }

            // Force refresh detection results
            await fetchDetectionResults();
          } else {
            showToast(`‚ùå Test th·∫•t b·∫°i: ${result.error}`, "error");
          }
        } catch (error) {
          console.error("Error testing face detection:", error);
          showToast("C√≥ l·ªói x·∫£y ra khi test ph√°t hi·ªán khu√¥n m·∫∑t", "error");
        }
      }

      // Real Camera Functions
      async function startWebcam() {
        try {
          showToast("ƒêang m·ªü camera...", "info");

          // Check if browser supports getUserMedia
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error(
              "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ WebRTC/Camera API. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Firefox, ho·∫∑c Edge phi√™n b·∫£n m·ªõi."
            );
          }

          // Check if we're in a secure context
          if (!window.isSecureContext && location.protocol !== "http:") {
            console.warn("Not in secure context, camera may not work");
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: "user", // Use front camera
            },
            audio: false,
          });

          webcamStream = stream;
          webcamVideo.srcObject = stream;

          // Wait for video to load
          await new Promise((resolve) => {
            webcamVideo.onloadedmetadata = () => {
              webcamVideo.play();
              resolve();
            };
          });

          // Show video, hide placeholder
          cameraPlaceholder.style.display = "none";
          webcamVideo.style.display = "block";

          // Update buttons
          startCameraBtn.style.display = "none";
          stopCameraBtn.style.display = "inline-block";
          testRealDetectionBtn.disabled = false;

          // Show stats
          detectionStats.style.display = "flex";
          updateRealCameraStats();

          showToast("Camera ƒë√£ ƒë∆∞·ª£c b·∫≠t th√†nh c√¥ng!", "success");
        } catch (error) {
          console.error("Error accessing webcam:", error);
          let errorMessage = "L·ªói khi m·ªü camera: " + error.message;

          if (error.name === "NotAllowedError") {
            errorMessage =
              '‚ùå Quy·ªÅn truy c·∫≠p camera b·ªã t·ª´ ch·ªëi. Vui l√≤ng:\n1. Click v√†o bi·ªÉu t∆∞·ª£ng üîí b√™n tr√°i thanh ƒë·ªãa ch·ªâ\n2. Ch·ªçn "Cho ph√©p" Camera\n3. L√†m m·ªõi trang v√† th·ª≠ l·∫°i';
          } else if (error.name === "NotFoundError") {
            errorMessage =
              "‚ùå Kh√¥ng t√¨m th·∫•y camera. Vui l√≤ng:\n1. Ki·ªÉm tra camera laptop c√≥ ho·∫°t ƒë·ªông kh√¥ng\n2. ƒê√≥ng c√°c ·ª©ng d·ª•ng kh√°c ƒëang s·ª≠ d·ª•ng camera\n3. Th·ª≠ l·∫°i";
          } else if (error.name === "NotSupportedError") {
            errorMessage =
              "‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Camera API. Vui l√≤ng s·ª≠ d·ª•ng:\n‚Ä¢ Chrome 53+\n‚Ä¢ Firefox 36+\n‚Ä¢ Safari 11+\n‚Ä¢ Edge 12+";
          } else if (error.message.includes("getUserMedia")) {
            errorMessage =
              "‚ùå Camera API kh√¥ng kh·∫£ d·ª•ng. H√£y th·ª≠:\n1. M·ªü b·∫±ng HTTPS n·∫øu c√≥ th·ªÉ\n2. S·ª≠ d·ª•ng tr√¨nh duy·ªát m·ªõi h∆°n\n3. Ki·ªÉm tra quy·ªÅn camera trong settings";
          }

          showToast(errorMessage, "error");
        }
      }

      function stopWebcam() {
        if (webcamStream) {
          webcamStream.getTracks().forEach((track) => track.stop());
          webcamStream = null;
        }

        // Hide video, show placeholder
        webcamVideo.style.display = "none";
        cameraPlaceholder.style.display = "flex";

        // Update buttons
        startCameraBtn.style.display = "inline-block";
        stopCameraBtn.style.display = "none";
        testRealDetectionBtn.disabled = true;

        showToast("Camera ƒë√£ ƒë∆∞·ª£c t·∫Øt", "info");
      }

      async function testRealFaceDetection() {
        if (!webcamStream) {
          showToast("Vui l√≤ng b·∫≠t camera tr∆∞·ªõc", "warning");
          return;
        }

        try {
          showToast("ƒêang ph√°t hi·ªán khu√¥n m·∫∑t...", "info");

          // Capture current frame from video
          const canvas = webcamCanvas;
          const context = canvas.getContext("2d");
          canvas.width = webcamVideo.videoWidth;
          canvas.height = webcamVideo.videoHeight;

          // Draw current video frame to canvas
          context.drawImage(webcamVideo, 0, 0);

          // Convert canvas to base64
          const imageData = canvas.toDataURL("image/jpeg", 0.8);

          // Send to backend for face detection
          const response = await fetch("/api/test-real-camera", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ image: imageData }),
          });

          const result = await response.json();

          if (result.success) {
            realCameraStats.testsRun++;

            if (result.faces_detected > 0) {
              realCameraStats.facesDetected += result.faces_detected;
              showToast(`‚úÖ ${result.message}`, "success");

              // Auto switch to detection results tab
              const detectionsTab = document.querySelector(
                '.main-content .tab-item[data-tab="detections"]'
              );
              if (detectionsTab) {
                detectionsTab.click();
              }

              // Refresh detection results
              await fetchDetectionResults();
            } else {
              showToast("‚ÑπÔ∏è " + result.message, "info");
            }

            updateRealCameraStats();
          } else {
            showToast("‚ùå L·ªói: " + result.error, "error");
          }
        } catch (error) {
          console.error("Error testing real face detection:", error);
          showToast("C√≥ l·ªói x·∫£y ra khi ph√°t hi·ªán khu√¥n m·∫∑t", "error");
        }
      }

      function updateRealCameraStats() {
        testsCountEl.textContent = realCameraStats.testsRun;
        facesCountEl.textContent = realCameraStats.facesDetected;

        if (realCameraStats.testsRun > 0) {
          const successRate = (
            (realCameraStats.facesDetected / realCameraStats.testsRun) *
            100
          ).toFixed(1);
          successRateEl.textContent = successRate + "%";
        } else {
          successRateEl.textContent = "0%";
        }
      }

      function checkBrowserSupport() {
        let supportInfo = "üîç Th√¥ng tin tr√¨nh duy·ªát:\n\n";

        // Browser info
        supportInfo += `üì± User Agent: ${navigator.userAgent}\n\n`;

        // WebRTC support
        const hasGetUserMedia = !!(
          navigator.mediaDevices && navigator.mediaDevices.getUserMedia
        );
        const hasLegacyGetUserMedia = !!(
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia
        );

        supportInfo += `üìπ Camera API:\n`;
        supportInfo += `  ‚Ä¢ Modern API (mediaDevices): ${
          hasGetUserMedia ? "‚úÖ C√≥" : "‚ùå Kh√¥ng"
        }\n`;
        supportInfo += `  ‚Ä¢ Legacy API: ${
          hasLegacyGetUserMedia ? "‚úÖ C√≥" : "‚ùå Kh√¥ng"
        }\n\n`;

        // HTTPS check
        const isSecure =
          window.isSecureContext ||
          location.protocol === "https:" ||
          location.hostname === "localhost";
        supportInfo += `üîê Secure Context: ${
          isSecure ? "‚úÖ C√≥" : "‚ö†Ô∏è Kh√¥ng (c·∫ßn HTTPS)"
        }\n\n`;

        // Overall compatibility
        const isCompatible =
          (hasGetUserMedia || hasLegacyGetUserMedia) && isSecure;
        supportInfo += `üéØ T·ªïng k·∫øt: ${
          isCompatible ? "‚úÖ T∆∞∆°ng th√≠ch" : "‚ùå Kh√¥ng t∆∞∆°ng th√≠ch"
        }\n\n`;

        if (!isCompatible) {
          supportInfo += `üí° Khuy·∫øn ngh·ªã:\n`;
          if (!hasGetUserMedia && !hasLegacyGetUserMedia) {
            supportInfo += `  ‚Ä¢ C·∫≠p nh·∫≠t tr√¨nh duy·ªát l√™n phi√™n b·∫£n m·ªõi\n`;
          }
          if (!isSecure) {
            supportInfo += `  ‚Ä¢ S·ª≠ d·ª•ng HTTPS ho·∫∑c localhost\n`;
          }
        }

        showToast(supportInfo, isCompatible ? "success" : "warning");
      }
    </script>
  </body>
</html>
